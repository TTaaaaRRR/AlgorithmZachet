## Оглавление (тыкается)
* [Билет 1](#bilet1)
* [Билет 2](#bilet2)
* [Билет 3](#bilet3)
* [Билет 4](#bilet4)
* [Билет 5](#bilet5)
* [Билет 6](#bilet6)
* [Билет 7](#bilet7)
* [Билет 8](#bilet8)
* [Билет 9](#bilet9)
* [Билет 10](#bilet10)

<a name="bilet1">.</a> 
## Билет 1
Базовое понятие алгоритма. Основные определения, примеры. Свойства алгоритмов.  Модель вычислений. RAM-модель. Элементарные (встроенные) типы данных, операции над ними. Понятие сложности алгоритмов. Понятия О-большое, Омега-большое. Описательная, пространственная, вычислительная сложности вложенных циклов. 

### 1. Понятие и свойства алгоритма

**Алгоритм** — это конечная последовательность чётко определённых действий (инструкций) для решения конкретной задачи.

* **Пример из жизни:** Рецепт торта.
* **Простой пример на Python:** Алгоритм поиска максимального элемента в списке.

```python
def find_max(data_list):
  max_value = data_list[0]
  for item in data_list:
    if item > max_value:
      max_value = item
  return max_value
```

***

### 2. Свойства алгоритмов

* **Дискретность:** Алгоритм состоит из отдельных шагов.
* **Детерминированность (Определённость):** Каждый шаг строго определён и не допускает двусмысленности.
* **Конечность:** Алгоритм должен завершиться за конечное число шагов.
* **Массовость:** Алгоритм применим к разным наборам исходных данных.
* **Результативность:** Алгоритм должен приводить к правильному результату.

***

### 3. Модель вычислений (RAM-модель)

**Модель вычислений** — это абстрактная машина, определяющая базовый набор операций.

**RAM-модель (Random Access Machine)** — наиболее распространённая модель:
* Память состоит из ячеек с произвольным доступом (чтение/запись за $O(1)$).
* Все базовые арифметические и логические операции (+, -, *, /, and, or, if) выполняются за константное время — $O(1)$.
* Инструкции выполняются последовательно.

***

### 4. Элементарные типы данных

Это встроенные в язык типы данных. В Python это:
* **int:** Целые числа (`5`, `-10`). Операции: `+`, `-`, `*`, `/`, `%`.
* **float:** Числа с плавающей точкой (`3.14`, `-0.5`). Операции: `+`, `-`, `*`, `/`.
* **bool:** Логический тип (`True`, `False`). Операции: `and`, `or`, `not`.
* **str:** Строки (`"hello"`). Операции: `+` (конкатенация).

***

### 5. Понятие сложности алгоритмов

**Сложность алгоритма** — это мера ресурсов (времени или памяти), которые требуются алгоритму для выполнения, как функция от размера входных данных `n`.

* **Временная сложность (Time Complexity):** Сколько времени работает алгоритм.
* **Пространственная сложность (Space Complexity):** Сколько дополнительной памяти использует алгоритм.

***

### 6. O-большое и $\Omega$-большое

Это асимптотические нотации для оценки сложности.

* **O-большое (Big O):** Верхняя граница, **худший случай**. Описывает, как медленно может работать алгоритм. Например, $O(n^2)$ означает, что время работы растёт не быстрее, чем квадрат от размера входных данных.

* **$\Omega$-большое (Big Omega):** Нижняя граница, **лучший случай**. Описывает, как быстро может работать алгоритм. Например, $\Omega(n)$ означает, что в лучшем случае алгоритм выполнится не быстрее, чем за линейное время.

***

### 7. Сложности вложенных циклов
<a name="твоё_название"></a> 
Рассмотрим пример:

```python
def process_matrix(matrix):
  n = len(matrix)
  for i in range(n):      # Внешний цикл
    for j in range(n):    # Внутренний цикл
      print(matrix[i][j]) # Операция за O(1)
```

* **Описательная сложность:** Время работы алгоритма пропорционально квадрату размера входной матрицы.
* **Пространственная сложность:** Алгоритм использует несколько переменных (`n`, `i`, `j`), их количество не зависит от размера `matrix`. Сложность по памяти — $O(1)$ (константная).
* **Вычислительная (временная) сложность:** Внешний цикл выполняется `n` раз, и для каждой итерации внутренний цикл также выполняется `n` раз. Общее число операций: $n \times n = n^2$. Сложность — $O(n^2)$.


<a name="bilet2">.</a> 
## Билет 2.
Линейные типы данных. Массив, односвязный список, двусвязный список. Интерфейс списка. Операции добавления, удаления, поиска элемента по значению, определение максимума массива. Квадратичные методы сортировки. Сортировки за O(n*log n).

### 1. Линейные структуры данных

Это структуры, в которых элементы расположены **последовательно**, один за другим.

***

### 2. Массив (Array)

**Массив** — это структура данных, хранящая элементы одного типа в **непрерывном блоке памяти**. Главная особенность — **быстрый доступ к элементу по индексу за $O(1)$**.

* **Плюсы:** Быстрый доступ по индексу.
* **Минусы:** Медленное добавление/удаление элементов в середину ($O(n)$), так как требует сдвига других элементов.
* **В Python:** роль массива выполняет встроенный тип `list` (динамический массив).

```python
# Массив в Python — это list
my_array = [10, 20, 30, 40]
print(my_array[1]) # -> 20 (доступ за O(1))
```

***

### 3. Односвязный список (Singly Linked List)

**Односвязный список** — это набор **узлов (nodes)**, где каждый узел содержит данные и **ссылку (указатель) на следующий узел**. Доступ к элементам последовательный, начиная с головы (`head`).

* **Плюсы:** Быстрое добавление/удаление в начало списка ($O(1)$).
* **Минусы:** Медленный доступ к элементу по индексу и поиск ($O(n)$).

```python
# Упрощенная структура узла
class Node:
  def __init__(self, data=None):
    self.data = data
    self.next = None
```

***

### 4. Двусвязный список (Doubly Linked List)

Похож на односвязный, но каждый узел также имеет **ссылку на предыдущий элемент**.

* **Плюсы:** Быстрое добавление/удаление в начало и конец ($O(1)$). Можно проходить по списку в обе стороны.
* **Минусы:** Занимает немного больше памяти из-за второй ссылки.

```python
# Упрощенная структура узла
class Node:
  def __init__(self, data=None):
    self.data = data
    self.next = None
    self.prev = None
```

***

### 5. Сравнение и интерфейс списка

| Операция | Массив (list) | Односвязный список | Двусвязный список |
| :--- | :---: | :---: | :---: |
| **Доступ по индексу** | $O(1)$ | $O(n)$ | $O(n)$ |
| **Поиск по значению** | $O(n)$ | $O(n)$ | $O(n)$ |
| **Вставка/удаление в начале** | $O(n)$ | $O(1)$ | $O(1)$ |
| **Вставка/удаление в конце**| $O(1)$ (в среднем) | $O(n)$ или $O(1)$* | $O(1)$ |
| **Вставка/удаление в середине**| $O(n)$ | $O(n)$ | $O(n)$ |
*\*Если хранить ссылку на хвост (tail), то $O(1)$.*

***

### 6. Основные операции для массива (Python `list`)

```python
data = [10, 50, 20, 90, 40]

# 1. Добавление (в конец)
data.append(60) # O(1)
print(data) # -> [10, 50, 20, 90, 40, 60]

# 2. Удаление (по значению)
data.remove(20) # O(n)
print(data) # -> [10, 50, 90, 40, 60]

# 3. Поиск элемента по значению (возвращает индекс)
try:
    index = data.index(90) # O(n)
    print(f"Элемент 90 на позиции: {index}") # -> Элемент 90 на позиции: 2
except ValueError:
    print("Элемент не найден")

# 4. Определение максимума
max_value = max(data) # O(n)
print(f"Максимум: {max_value}") # -> Максимум: 90
```

***

### 7. Квадратичные сортировки ($O(n^2)$) 🐢

Эти алгоритмы просты в реализации, но неэффективны на больших данных. В основе лежат вложенные циклы.

* **Сортировка пузырьком (Bubble Sort):** Соседние элементы сравниваются и меняются местами, если они в неправильном порядке.
* **Сортировка выбором (Selection Sort):** Находим минимальный элемент и ставим его в начало, затем ищем следующий минимальный для оставшейся части и т.д.
* **Сортировка вставками (Insertion Sort):** Берём элементы по одному и "вставляем" их на правильное место в уже отсортированной части массива.

**Пример: Сортировка пузырьком**
```python
def bubble_sort(arr):
  n = len(arr)
  for i in range(n):
    for j in range(0, n-i-1):
      if arr[j] > arr[j+1]:
        arr[j], arr[j+1] = arr[j+1], arr[j] # Обмен
  return arr

print(bubble_sort([64, 34, 25, 12, 22, 11, 90]))
```

***

### 8. Быстрые сортировки ($O(n \log n)$) 🚀

Гораздо эффективнее. Используют принцип **"разделяй и властвуй"**.

* **Сортировка слиянием (Merge Sort):** Массив рекурсивно делится пополам до тех пор, пока не останутся единичные элементы. Затем отсортированные части "сливаются" вместе.
* **Быстрая сортировка (Quick Sort):** Выбирается "опорный" элемент (pivot). Массив делится на две части: элементы меньше опорного и элементы больше опорного. Затем части рекурсивно сортируются.

**Пример: Быстрая сортировка**
```python
def quick_sort(arr):
  if len(arr) <= 1:
    return arr
  else:
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

print(quick_sort([64, 34, 25, 12, 22, 11, 90]))
```
